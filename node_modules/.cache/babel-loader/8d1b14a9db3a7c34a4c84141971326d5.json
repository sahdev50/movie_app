{"ast":null,"code":"(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('react')) : typeof define === 'function' && define.amd ? define(['exports', 'react'], factory) : (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.ReactErrorBoundary = {}, global.React));\n})(this, function (exports, React) {\n  'use strict';\n\n  function _inheritsLoose(subClass, superClass) {\n    subClass.prototype = Object.create(superClass.prototype);\n    subClass.prototype.constructor = subClass;\n    subClass.__proto__ = superClass;\n  }\n\n  var changedArray = function (a, b) {\n    if (a === void 0) {\n      a = [];\n    }\n\n    if (b === void 0) {\n      b = [];\n    }\n\n    return a.length !== b.length || a.some(function (item, index) {\n      return !Object.is(item, b[index]);\n    });\n  };\n\n  var initialState = {\n    error: null\n  };\n\n  var ErrorBoundary = /*#__PURE__*/function (_React$Component) {\n    _inheritsLoose(ErrorBoundary, _React$Component);\n\n    function ErrorBoundary() {\n      var _this;\n\n      for (var _len = arguments.length, _args = new Array(_len), _key = 0; _key < _len; _key++) {\n        _args[_key] = arguments[_key];\n      }\n\n      _this = _React$Component.call.apply(_React$Component, [this].concat(_args)) || this;\n      _this.state = initialState;\n      _this.updatedWithError = false;\n\n      _this.resetErrorBoundary = function () {\n        var _this$props;\n\n        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n          args[_key2] = arguments[_key2];\n        }\n\n        _this.props.onReset == null ? void 0 : (_this$props = _this.props).onReset.apply(_this$props, args);\n\n        _this.reset();\n      };\n\n      return _this;\n    }\n\n    ErrorBoundary.getDerivedStateFromError = function getDerivedStateFromError(error) {\n      return {\n        error: error\n      };\n    };\n\n    var _proto = ErrorBoundary.prototype;\n\n    _proto.reset = function reset() {\n      this.updatedWithError = false;\n      this.setState(initialState);\n    };\n\n    _proto.componentDidCatch = function componentDidCatch(error, info) {\n      var _this$props$onError, _this$props2;\n\n      (_this$props$onError = (_this$props2 = this.props).onError) == null ? void 0 : _this$props$onError.call(_this$props2, error, info);\n    };\n\n    _proto.componentDidUpdate = function componentDidUpdate(prevProps) {\n      var error = this.state.error;\n      var resetKeys = this.props.resetKeys; // There's an edge case where if the thing that triggered the error\n      // happens to *also* be in the resetKeys array, we'd end up resetting\n      // the error boundary immediately. This would likely trigger a second\n      // error to be thrown.\n      // So we make sure that we don't check the resetKeys on the first call\n      // of cDU after the error is set\n\n      if (error !== null && !this.updatedWithError) {\n        this.updatedWithError = true;\n        return;\n      }\n\n      if (error !== null && changedArray(prevProps.resetKeys, resetKeys)) {\n        var _this$props$onResetKe, _this$props3;\n\n        (_this$props$onResetKe = (_this$props3 = this.props).onResetKeysChange) == null ? void 0 : _this$props$onResetKe.call(_this$props3, prevProps.resetKeys, resetKeys);\n        this.reset();\n      }\n    };\n\n    _proto.render = function render() {\n      var error = this.state.error; // @ts-expect-error ts(2339) (at least one of these will be defined though, and we check for their existance)\n\n      var _this$props4 = this.props,\n          fallbackRender = _this$props4.fallbackRender,\n          FallbackComponent = _this$props4.FallbackComponent,\n          fallback = _this$props4.fallback;\n\n      if (error !== null) {\n        var _props = {\n          error: error,\n          resetErrorBoundary: this.resetErrorBoundary\n        };\n\n        if ( /*#__PURE__*/React.isValidElement(fallback)) {\n          return fallback;\n        } else if (typeof fallbackRender === 'function') {\n          return fallbackRender(_props);\n        } else if (FallbackComponent) {\n          return /*#__PURE__*/React.createElement(FallbackComponent, _props);\n        } else {\n          throw new Error('react-error-boundary requires either a fallback, fallbackRender, or FallbackComponent prop');\n        }\n      }\n\n      return this.props.children;\n    };\n\n    return ErrorBoundary;\n  }(React.Component);\n\n  function withErrorBoundary(Component, errorBoundaryProps) {\n    var Wrapped = function (props) {\n      return /*#__PURE__*/React.createElement(ErrorBoundary, errorBoundaryProps, /*#__PURE__*/React.createElement(Component, props));\n    }; // Format for display in DevTools\n\n\n    var name = Component.displayName || Component.name || 'Unknown';\n    Wrapped.displayName = \"withErrorBoundary(\" + name + \")\";\n    return Wrapped;\n  }\n\n  function useErrorHandler(givenError) {\n    var _React$useState = React.useState(null),\n        error = _React$useState[0],\n        setError = _React$useState[1];\n\n    if (givenError) throw givenError;\n    if (error) throw error;\n    return setError;\n  }\n  /*\n  eslint\n    @typescript-eslint/no-throw-literal: \"off\",\n    @typescript-eslint/prefer-nullish-coalescing: \"off\"\n  */\n\n\n  exports.ErrorBoundary = ErrorBoundary;\n  exports.useErrorHandler = useErrorHandler;\n  exports.withErrorBoundary = withErrorBoundary;\n  Object.defineProperty(exports, '__esModule', {\n    value: true\n  });\n});","map":{"version":3,"sources":["../node_modules/@babel/runtime/helpers/esm/inheritsLoose.js","../src/index.tsx"],"names":["subClass","Object","superClass","changedArray","a","b","initialState","error","ErrorBoundary","React","getDerivedStateFromError","state","updatedWithError","resetErrorBoundary","args","reset","componentDidCatch","componentDidUpdate","resetKeys","prevProps","render","fallbackRender","FallbackComponent","fallback","props","React.createElement","Wrapped","name","Component","setError"],"mappings":"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","sourcesContent":["export default function _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  subClass.__proto__ = superClass;\n}","import * as React from 'react'\n\nconst changedArray = (a: Array<unknown> = [], b: Array<unknown> = []) =>\n  a.length !== b.length || a.some((item, index) => !Object.is(item, b[index]))\n\ninterface FallbackProps {\n  error: Error\n  resetErrorBoundary: (...args: Array<unknown>) => void\n}\n\ninterface ErrorBoundaryPropsWithComponent {\n  onResetKeysChange?: (\n    prevResetKeys: Array<unknown> | undefined,\n    resetKeys: Array<unknown> | undefined,\n  ) => void\n  onReset?: (...args: Array<unknown>) => void\n  onError?: (error: Error, info: {componentStack: string}) => void\n  resetKeys?: Array<unknown>\n  FallbackComponent: React.ComponentType<FallbackProps>\n}\n\ndeclare function FallbackRender(\n  props: FallbackProps,\n): React.ReactElement<\n  unknown,\n  string | React.FunctionComponent | typeof React.Component\n> | null\n\ninterface ErrorBoundaryPropsWithRender {\n  onResetKeysChange?: (\n    prevResetKeys: Array<unknown> | undefined,\n    resetKeys: Array<unknown> | undefined,\n  ) => void\n  onReset?: (...args: Array<unknown>) => void\n  onError?: (error: Error, info: {componentStack: string}) => void\n  resetKeys?: Array<unknown>\n  fallbackRender: typeof FallbackRender\n}\n\ninterface ErrorBoundaryPropsWithFallback {\n  onResetKeysChange?: (\n    prevResetKeys: Array<unknown> | undefined,\n    resetKeys: Array<unknown> | undefined,\n  ) => void\n  onReset?: (...args: Array<unknown>) => void\n  onError?: (error: Error, info: {componentStack: string}) => void\n  resetKeys?: Array<unknown>\n  fallback: React.ReactElement<\n    unknown,\n    string | React.FunctionComponent | typeof React.Component\n  > | null\n}\n\ntype ErrorBoundaryProps =\n  | ErrorBoundaryPropsWithFallback\n  | ErrorBoundaryPropsWithComponent\n  | ErrorBoundaryPropsWithRender\n\ntype ErrorBoundaryState = {error: Error | null}\n\nconst initialState: ErrorBoundaryState = {error: null}\n\nclass ErrorBoundary extends React.Component<\n  React.PropsWithRef<React.PropsWithChildren<ErrorBoundaryProps>>,\n  ErrorBoundaryState\n> {\n  static getDerivedStateFromError(error: Error) {\n    return {error}\n  }\n\n  state = initialState\n  updatedWithError = false\n  resetErrorBoundary = (...args: Array<unknown>) => {\n    this.props.onReset?.(...args)\n    this.reset()\n  }\n\n  reset() {\n    this.updatedWithError = false\n    this.setState(initialState)\n  }\n\n  componentDidCatch(error: Error, info: React.ErrorInfo) {\n    this.props.onError?.(error, info)\n  }\n\n  componentDidUpdate(prevProps: ErrorBoundaryProps) {\n    const {error} = this.state\n    const {resetKeys} = this.props\n\n    // There's an edge case where if the thing that triggered the error\n    // happens to *also* be in the resetKeys array, we'd end up resetting\n    // the error boundary immediately. This would likely trigger a second\n    // error to be thrown.\n    // So we make sure that we don't check the resetKeys on the first call\n    // of cDU after the error is set\n    if (error !== null && !this.updatedWithError) {\n      this.updatedWithError = true\n      return\n    }\n\n    if (error !== null && changedArray(prevProps.resetKeys, resetKeys)) {\n      this.props.onResetKeysChange?.(prevProps.resetKeys, resetKeys)\n      this.reset()\n    }\n  }\n\n  render() {\n    const {error} = this.state\n    // @ts-expect-error ts(2339) (at least one of these will be defined though, and we check for their existance)\n    const {fallbackRender, FallbackComponent, fallback} = this.props\n\n    if (error !== null) {\n      const props = {\n        error,\n        resetErrorBoundary: this.resetErrorBoundary,\n      }\n      if (React.isValidElement(fallback)) {\n        return fallback\n      } else if (typeof fallbackRender === 'function') {\n        return (fallbackRender as typeof FallbackRender)(props)\n      } else if (FallbackComponent) {\n        return <FallbackComponent {...props} />\n      } else {\n        throw new Error(\n          'react-error-boundary requires either a fallback, fallbackRender, or FallbackComponent prop',\n        )\n      }\n    }\n\n    return this.props.children\n  }\n}\n\nfunction withErrorBoundary<P>(\n  Component: React.ComponentType<P>,\n  errorBoundaryProps: ErrorBoundaryProps,\n): React.ComponentType<P> {\n  const Wrapped: React.ComponentType<P> = props => {\n    return (\n      <ErrorBoundary {...errorBoundaryProps}>\n        <Component {...props} />\n      </ErrorBoundary>\n    )\n  }\n\n  // Format for display in DevTools\n  const name = Component.displayName || Component.name || 'Unknown'\n  Wrapped.displayName = `withErrorBoundary(${name})`\n\n  return Wrapped\n}\n\nfunction useErrorHandler<P = Error>(\n  givenError?: P | null | undefined,\n): React.Dispatch<React.SetStateAction<P | null>> {\n  const [error, setError] = React.useState<P | null>(null)\n  if (givenError) throw givenError\n  if (error) throw error\n  return setError\n}\n\nexport {ErrorBoundary, withErrorBoundary, useErrorHandler}\nexport type {\n  FallbackProps,\n  ErrorBoundaryPropsWithComponent,\n  ErrorBoundaryPropsWithRender,\n  ErrorBoundaryPropsWithFallback,\n  ErrorBoundaryProps,\n}\n\n/*\neslint\n  @typescript-eslint/no-throw-literal: \"off\",\n  @typescript-eslint/prefer-nullish-coalescing: \"off\"\n*/\n"]},"metadata":{},"sourceType":"script"}